# 스프링과 스프링 부트의 차이

## Spring Boot
쉽게 만들고, 단독적으로 만들 수 있으며, 상용화 수준까지 단순하게 만들수 있고
스프링 기반 어플리케이션을 만들어준다.

내장 웹서버(tomcat)가 있기 때문에 서버 구동시간이 매우 단순해지며, config에서 jetty등으로 바꿀 수 있다.

security, data JPA 등의 다른 스프링 프레임워크 요소를 쉽게 사용할 수 있음.
**dependency**

스프링은 가 너무 길고, 버전 정보까지 전부 직접 설정해야하나

스프링 부트는 보다 짧게 관리가 가능하며 버전 관리를 권장 버전으로 자동 설정해준다.

**configuration**

스프링 부트는 application.properties(application.yml)만 설정해주면 됨

# 라이브러리 살펴보기

maven, gradle은 라이브러리간의 의존성을 관리해준다.

**tomcat embe**

과거에는 WAS를 직접 서버에 설치 한 후 자바 코드를 밀어넣는 방식 (웹서버와 개발 코드가 분리)

지금은 embeded되어있는 상태로 build한 후 올리면 완료된다.(내장 서블릿 컨테이너 덕분)

따라서 단순히 gradle르 build된 jar 파일만 서버에서 실행시키면 된다.

**logging**

로그로 출력해 기록을 남겨야 에러 발견등을 쉽게 할 수 있어서 중요하다.

slf4j: 인터페이스, logback: 어떻게 로그를 남길것인가 (검색해볼것)

**test**

junit: 최근들어 5version으로 넘어가기 시작함.

mockito: 목 라이브러리

assertj: 테스트 코드를 좀 더 편하게 작성해주는 도와주는 라이브러리

spring-test: 스프링 통합 테스트 지원

# controller와 static content

관련 controller를 찾을 수 있다면 viewResolver가 resouces의 template package에서 해당 파일명.html을 찾는다.

만약, 찾을 수 없다면 static폴더에서 정적 컨텐츠를 찾아 반환한다.

**@ResponseBody**

이때는 viewResolver가 아닌 HttpMessageConverter가 동작한다.

보통은 text로 반환(StringConverter가 동작)

객체가 오면 json형식(defualt, 여러 포맷을 다 지원해줌)로 반환(JsonConverter가 동작)

클라이언트의 HTTP Accept header와 서버 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택된다.

# 일반적인 웹 어플리케이션의 계층 구조
1. 컨트롤러: 웹 MVC의 컨트롤러 역할. 외부 요청을 받는다.
2. 서비스: 핵심 비지니스 로직 구현. method 이름을 보다 비지니스에 가깝게 설정.
3. 리포지토리: 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리. method 이름을 보다 데이터 관리에 가깝게 설정.
4. 도메인: 비지니스 도메인 객체. 예) 회원, 주문, 쿠폰 등등 주로 데이터베이스에 저장되고 관리됨

만약 아직 데이터 저장소가 정해지지 않았을 경우 repository를 interface로 만들어 구현 클래스를 변경할 수 있도록 설계한다.

# 테스트 코드 작성
given when then 으로 나누어서 작성하면 긴 테스트 코드일 경우 보다 명확히 보인다.
(상황에 따라 추가 변형)

# 서비스 빈과 의존관계
@Controller 어노테이션이 명시되어 있을 경우 스프링 컨테이너가 컨트롤러를 생성해서 관리한다.
@Autowired 어노테이션이 명시되어 있을 경우 Controller와 자동으로 연결시켜준다.

컨테이너에서 스프링 빈을 등록할 때 기본으로 싱글톤으로 등록된다.(유일하게 하나만 등록)
따라서 같은 스프링 빈이면 모두 같은 인스턴스이다. (싱글톤이 아니게 설정도 가능)

## 등록 방법
1. 컴포넌트 스캔과 자동 의존관계 설정

@Component 어노테이션이 있으면 스프링 빈으로 자동 등록된다.(@Controller도 @Component의 일종)

단, @SpringBootApplication가 명시된 package의 하위 package에서만 동작한다.

2. 자바 코드로 직접 스프링 빈 등록하

@Configuration 어노테이션을 가진 클래스를 만든 후 @Bean 어노테이션을 통해 각각 등록해준다.


정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용한다.
그리고 정형화되지 않거나, 상황에 따라 구현 클래스를 변경해야하면 설정을 통해 스프링 빈으로 등록한다.(직접 등록의 장점)

@Autowired를 통한 DI는 스프링이 관리하는 객체에서만 동작한다. 스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지 않는다.

@Autowired을 주입할 대상에 붙이면 해당 타입의 빈 객체를 찾아서 자동으로 주입된다.(일치하는 빈이 1개여야한다. @Qualifier를 사용하는 방법으로 해)

### 번외) DI
1. 생성자 주입: 생성자를 통해서 들어오는 형태. 가장 좋은 방법(의존 관계가 실행중에 동적으로 변하는 경우가 없으므로)
2. 필드 주입: 필드 자체에 @Autowired(좋은 방법 x)
3. setter 주입: setter에 @Autowired. 단점: 누군가가 member service를 호출할때 public하게 되야하는데 이때 노출되므로 문제가 발생할 수 있다.

**JDBC**
application과 database를 연결할 때 사용하는 기술
스프링 JdbcTemplate을 통해 보다 편리하게 사용할 수 있다.
**JPA**
등록 수정 삭제등의 쿼리를 객체없이 관리할 수 있다.
스프링에서 JPA를 간편하게 사용할 수 있도록하는 '스프링 데이터 JPA'도 있다. 
에
## SOLID 원칙
1. 단일 책임 원칙(SRP, Single Responsibility Principle)
모든 클래스는 각각 하나의 책임만 가져야한다. 클래스는 그 책임을 완전히 캡슐화해야 함을 말한다.
2. 개방-폐쇄 원칙(OCP, Open Closed Principle) 핵심
확장에는 열려있고 수정에는 닫혀있어야 한다. 기존의 코드는 변경하지 않으면서 기능을 추가할수 있어야한다.
3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다.
4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야한다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다.
5. 의존 역전 원칙(DIP, Dependency Inversion Principle)
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는것에 의존하라는 것이다.
한마디로 구체적인 클래스보다 인터페이스나 추상클래스와 관계를 맺으라는 것이다.

# Integration Test
@SpringBootTest를 사용해서 통합 환경 테스트를 진행할 수 있다.
이때 반복해서 Test를 해도 동일한 결과를 얻을 수 있도록 DB를 관리해줘야하는데, 이때 @Transactional(rollback 시켜준다.) 어노테이션을 사용한다.
@commit을 사용하면 Test후에 commit한다.

단위테스트를 진행할때는 Java에서만 이루어지도록 하는것이 좋다.(Spring container 없이 하는것이 좋은 테스트일 확률이 높다.)

# JdbcTemplate
JDBC API에서 본 반복 코드를 대부분 제거해준다.

##template method pattern

##Proxy pattern


# JPA
기존의 반복 코드뿐만 아니라 기본적인 SQL도 직접 만들어서 실행해준다.
SQL과 데이터 중심 설계에서 객체 중심의 설계로 패러다임을 전환할 수 있어 개발 생산성을 크게 높일 수 있다.
JPA는 표준 인터페이스이며 각 업체에서 자신만의 기술을 인터페이스에맞춰 구현한 라이브러리를 사용하게된다.
이번에 이용한것은 Hibernate구현체이다.

PK기반으로 찾는경우가 아니면 jpaql을 작성해줘야한다.

JPA를 사용할때는 service 객체에(변경이 발생하는 곳) @Transactional이 명시되어있어야한다.

# 스프링 데이터 JPA
리포지토리에 구현 클래스 없이 인터페이스만드로 개발이 완료된다. 반복적으로 개발한 CRUD기능도 제공한다.
관계형 데이터베이스를 사용한다면 JPA는 이제 필수이다.

JPA를 편하게 도와주는 도구이니 JPA를 제대로 배우고난 후에 사용하는것을 추천한다.

JpaRepository를 상속받고 있을 경우 Spring JPA가 구현체를 자동으로 만들어준다.

공통으로 구현되어 있는 method들이 존재하고(document를 보면 상세히 알 수 있음)
맞춤형으로 필요할 경우 규칙에 맞춰 작성하면 자동으로 만들어준다.

복잡한 동적쿼리는 Querydsl이라는 라이브러리를 사용해 만들고
이 조합으로도 해결하기 어려울 경우 JPA가 제공하는 네이티브 쿼리를 사용하거나 JdbcTemplate을 혼용하여 사용하면 된다.

# AOP
호출 시간을 측정할 때
핵심 관심 사항(실제 비지니스 코드)와 공통 관심 사항(시간 측정)이 섞여있어 유지보수가 어렵다.
별도의 공통 로직으로 만들기 어렵고, 변경이 필요할 때 모든 로직을 찾아가야하는 문제가 발생할때.

이 때 사용하는게 AOP이다.

즉 핵심 관심 사항과 공통 관심 사항을 분리하고, 원하는 곳에 공통 관심 사항을 적용하는 작업을 도와주는 방식이다.

@Aspect 어노테이션을 통해 만들 수 있다. 이후 Bean에 등

**장점**
핵심 관심 사항을 깔끔하게 유지할 수 있다.
변경이 필요할 경우 이 로직만 변경하면 된다.
원하는 적용 대상을 선택할 수 있다.

### 스프링 AOP 동작 방식
적용 전 의존 관계 사이에 Proxy로 가짜 service를 생성한다.
이후 joinPoint.proceed()가 실행되면 진짜 service를 실행시킨다.
결국 DI를 통해서 작동하기에 가능한 기술이다.